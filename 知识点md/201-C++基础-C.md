### 201-C++基础-C

1. ```c
   typedef struct ST {
   	int nNum;
   }NEW;
   
   struct MyStruct
   {
   	int n;
   }obj = { 1 };	// 在这里直接定义了一个变量
   
   int main()
   {
   	// ST不是一个结构体类型（值0 ）
   	// struct ST 两部分是一个完整的结构体类型
   	struct ST obj;
   
   	// typedef起别名
   	// NEW是一个结构体类型
   	
   
   	// 哪个是类型名？
   	// 哪个是变量名？
   	int nNum = 0;
   
   	// NEW是结构体类型，本质上和int，char，float一样
   	// 类型不占用任何空间，只有变量才占有内存
   	// nObj是一个变量名，结构体变量
   	NEW nObj;
   }
   ```

2. 

4. 结构体的大小是所有成员的和（需要对齐），联合体的大小是最大的成员的大小

5. 对一个指针free之后，没有置空的指针被称为“悬空指针

   定义了一个未初始化的指针叫“野指针”

   ```c
   	int* q = 0;	// q是野指针
   	// 定义出指针之后要给他赋初值，不要定义野指针
   	int* p = (int*)malloc(sizeof(int) * 10);
   	free(p);
   	// 这步p就是悬空指针
   	// 释放后把指针置空
   	p = 0;
   	// 使用悬空指针和野指针都会造成错误
   ```

   

6. 栈区，堆区，常量区，全局数据区（静态数据区），代码区

   ```c
   int g_nNum = 100;
   int main()
   {
   	// ，，，，
   
   	// 代码区:只能读取和执行，但是不能写入
   
   	// 栈区：保存局部变量的
   	int nNum = 0;
   	char szName[20] = { 0 };
   	printf("这里是栈区：%p\n", &nNum);
   	printf("这里是栈区：%p\n", szName);
   
   	// 堆区:用malloc申请的空间
   	int *p = (int*)malloc(sizeof(int) * 10);
   	int *p1 = (int*)malloc(sizeof(int) * 10);
   	printf("这里是堆区：%p\n", p);
   	printf("这里是堆区：%p\n", p1);
   
   	// 常量区
   	char *str = "helloworld";
   	printf("这里是常量区:%p\n", str);
   	printf("这里是栈区：%p\n", &str);
   
   	// 全局数据区（静态数据区）
   	printf("这里是全局数据区:%p\n", &g_nNum);
   	static int s_nNum = 0;
   	printf("这里是全局数据区:%p\n", &s_nNum);
   }
   ```

   

7. malloc返回值是void*，所以需要强转。

   malloc按照字节数申请的，所以大小需要类型的大小*申请的数量

8. ```c
   	// str1和str2是保存在栈区
   	char str1[] = "15pb";
   	char str2[] = { '1','5','p','b' };
   	// pStr1是在常量区，常量区的数据无法更改
   	// 所有指针类型的变量都是四个字节
   	char* pStr1 = "15pb";
   
   	str1[2] = 'a';
   	str2[2] = 'b';
   	pStr1[2] = 'c';
   ```

10. ```c
    	unsigned long a[] = { 6,7,8,9,10 };
    	unsigned long *p;
    	p = a;
    	// p+2指向了数组下标为2的元素的地址
    	// *(p + 2)访问到了地址中元素a[2]
    	*(p + 2) += 2;	//a[2]+=2;
    	printf("%d %d\n", *p, *(p + 2));
    	printf("%d %d\n", p[0], p[2]);
    	printf("%d %d\n", a[0], a[2]);
    	// 这三种写法等价
    ```

11. *(p++)，运算符优先级

    指针中保存了一个地址，解引用就是访问地址中的内容

12. ```c
    int a[3][4]
    *(*(a+1)+2)（值5 ）;
    // int a[3];
    // 一维数组名首元素的地址，也就是指向int的指针
    // 对数组名进行加法运算就是遍历数组中的元素
    a[0],a[1],a[2];
    *a,*(a+1),*(a+2);
    // 二维数组名是指向一维数组的指针
    // 二维数组的加法是遍历数组中的行
    ```

13. ```c
    	int a[3][4] = { 1,2,3,4,5,6,7,8,9,10 };
    	printf("a[1][2]:%d\n", a[1][2]);
    	printf("*(a[0]+1):%d\n", *(a[0] + 1));
    	// a[0] + 1指向第二行
    	// *(a[0] + 1)变为int类型,相当于a[1][0]
    
    	//printf("(&a[0]+1)[2]:%d\n", (&a[0] + 1)[2]);
    	// a[0]是一个一维数组
    	// &a[0]又变为一维数组指针，和二维数组名a是等价的
    	// &a[0]+1实际上就是&a[1]，指向了第二行的一维数组指针
    	// &a[0] + 1)[2]访问到的是一个数组，是这个二维数组的第4行，已经越界了
    
    
    	//printf("*(a+1+2):%d\n", *(a + 1 + 2));	// *(a+1+2)是一维数组
    	//printf("*(*(a+1)+2):%d\n", *(*(a + 1) + 2));
    ```

14. ```c
    int main()
    {
    	int a[3][3] = { {0,1,2},{3,4,5},{6,7,8} };
    	// 二维数组名a是什么类型？
    	// 一维数组名是指向int类型的指针
    	// 二维数组名就是指向一个一维数组的指针
    
    	// a+1加4*3个字节
    	int* p = (int*)a;
    	// p是什么类型？p是一个指针
    	// p+1加4个字节
    	printf("%d", *(p + 2));
    }
    // 0,1,2
    // 3,4,5
    // 6,7,8
    ```

15. ```c
    	int x[6][4], (*p)[4];
    	p = x;
    	// p是一个数组指针
    	// *p一个4个元素的一维数组 
    	*(*(p+0)+2);
    	x[0][2];
    ```

16. 二维数组再传参时，会退化成一维数组指针

